<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Forward modelling with a circular surface loop · SNMRForward</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="SNMRForward logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SNMRForward</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">SNMRForward.jl Documentation</a></li><li><span class="tocitem">Examples</span><ul><li class="is-active"><a class="tocitem" href>Forward modelling with a circular surface loop</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Setup"><span>Setup</span></a></li><li><a class="tocitem" href="#Physical-parameters"><span>Physical parameters</span></a></li><li><a class="tocitem" href="#Excitation-field"><span>Excitation field</span></a></li><li><a class="tocitem" href="#Modelling-kernel"><span>Modelling kernel</span></a></li><li><a class="tocitem" href="#Tipping-angle"><span>Tipping angle</span></a></li><li><a class="tocitem" href="#D-kernel-for-different-pulse-moments"><span>1D kernel for different pulse moments</span></a></li><li><a class="tocitem" href="#Forward-modelling-of-the-sounding-curve"><span>Forward modelling of the sounding curve</span></a></li><li><a class="tocitem" href="#Depth-slices-of-sensitivity"><span>Depth slices of sensitivity</span></a></li><li><a class="tocitem" href="#The-forward-modelling-API"><span>The forward modelling API</span></a></li></ul></li></ul></li><li><span class="tocitem">API docs</span><ul><li><a class="tocitem" href="../../forward_modelling/">Forward Modelling</a></li><li><a class="tocitem" href="../../constants/">Constants and convenience functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Forward modelling with a circular surface loop</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Forward modelling with a circular surface loop</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/richardt94/SNMRForward.jl/blob/master/scripts/forward_model.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Forward-modelling-with-a-circular-surface-loop"><a class="docs-heading-anchor" href="#Forward-modelling-with-a-circular-surface-loop">Forward modelling with a circular surface loop</a><a id="Forward-modelling-with-a-circular-surface-loop-1"></a><a class="docs-heading-anchor-permalink" href="#Forward-modelling-with-a-circular-surface-loop" title="Permalink"></a></h1><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>This example shows the &quot;under the hood&quot; workings of the SNMRForward code, through demonstrating the modelling of a 1D magnetic resonance sounding experiment with a single, circular surface loop.</p><h2 id="Setup"><a class="docs-heading-anchor" href="#Setup">Setup</a><a id="Setup-1"></a><a class="docs-heading-anchor-permalink" href="#Setup" title="Permalink"></a></h2><p>Use the SNMRForward package and PyPlot for plotting</p><pre><code class="language-julia hljs">using SNMRForward, PyPlot</code></pre><h2 id="Physical-parameters"><a class="docs-heading-anchor" href="#Physical-parameters">Physical parameters</a><a id="Physical-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Physical-parameters" title="Permalink"></a></h2><p>Set dimensions for radius and the modelling discretisation grid</p><pre><code class="language-julia hljs">R = 50
rgrid = R * (0.01:0.01:2.5)
zgrid = R * (0.01:0.01:2)</code></pre><pre><code class="nohighlight hljs">0.5:0.5:100.0</code></pre><p>Conductive half-space, 0.001 S/m at 2.5 kHz Larmor frequency. γh is the gyromagnetic ratio of hydrogen bound in water molecules and allows conversion between Larmor frequency and magnetic field intensity.</p><pre><code class="language-julia hljs">#
ωl = 2*π*2.5e3 #Hz, typical for Earth&#39;s field strength
Be = ωl/SNMRForward.γh
d = Vector{Float64}()#[20.0,30.0]
σ = [0.001]#,0.1, 0.02]</code></pre><pre><code class="nohighlight hljs">1-element Vector{Float64}:
 0.001</code></pre><h2 id="Excitation-field"><a class="docs-heading-anchor" href="#Excitation-field">Excitation field</a><a id="Excitation-field-1"></a><a class="docs-heading-anchor-permalink" href="#Excitation-field" title="Permalink"></a></h2><p>This cell calculates the subsurface field produced by the surface coil. This function calculates this by inversion from the Hankel domain using &quot;quadrature with extrapolation&quot; (see Kerry Key, Geophysics 77(3), F21-F30 (2012)), which is more numerically stable for evaluation of the field in the near surface, where the Hankel transform integral is oscillatory and converges slowly.</p><pre><code class="language-julia hljs">(Hz,Hr) = SNMRForward.magfields_qwe(R,ωl,σ,d,rgrid,zgrid)

# plot the real part of the fields
fig, ax = subplots(1,2)
sca(ax[1])
pcolor(rgrid, zgrid, real.(Hz)&#39;, vmin = -0.01, vmax=0.01)
gca().invert_yaxis()
sca(ax[2])
pcolor(rgrid, zgrid, real.(Hr)&#39;, vmin = -0.01, vmax=0.01)
gca().invert_yaxis()
gcf()</code></pre><p><img src="../2458225417.png" alt/></p><p>Decompose the excitation field into components that rotate with and against the precession of nuclear spin, assuming a geomagnetic field inclination of 65° (or 13π/36 radians). There is also a phase lag ζ which depends on the subsurface conductivity. Then make a plot of these field components.</p><pre><code class="language-julia hljs">#
ϕ = 13*π/36
Hfield_params = SNMRForward.co_counter_field.(Hz, Hr, ϕ, -π/2)

Hco = first.(Hfield_params)
ζ = last.(Hfield_params)


H_counter = reshape([a[2] for a in Hfield_params[:]], size(Hco)...)

#
fig, ax = subplots(1,2,figsize=(10,8))
sca(ax[1])
ylabel(&quot;z (m)&quot;)
xlabel(&quot;r (m)&quot;)
title(&quot;co-rotating field&quot;)
contourf(rgrid, zgrid, log.(Hco)&#39;, [-12,-7,-6.5,-6.0,-5.5,-5.0,-4.0,-3.0,-1.0])
gca().invert_yaxis()
sca(ax[2])
title(&quot;counter-rotating field&quot;)
xlabel(&quot;r (m)&quot;)
cs = contourf(rgrid, zgrid, log.(H_counter)&#39;, [-12,-7,-6.5,-6.0,-5.5,-5.0,-4.0,-3.0,-1.0])
gca().invert_yaxis()

colorbar(cs,location=&quot;bottom&quot;, ax=ax, label = &quot;log H&quot;)

gcf()</code></pre><p><img src="../4098531767.png" alt/></p><p>Show the phase lag as a contour plot</p><pre><code class="language-julia hljs">#

figure()
cs = contourf(rgrid, zgrid, ζ&#39;)
gca().invert_yaxis()
colorbar(cs)
gcf()</code></pre><p><img src="../2155693609.png" alt/></p><p>Plot up the co- and counter-rotating B fields with actual value of excitation current (300 A). B-field is shown in Gauss.</p><pre><code class="language-julia hljs"># H -&gt; B in tesla or gauss
# for a 300 A current, normalised to match figure 1 of weichman
μ_G = 4*π * 1e-3
norm_factor = 300 * μ_G / 0.299895
fig, ax = subplots(1,2,figsize=(10,8))
sca(ax[1])
ylabel(&quot;z (m)&quot;)
xlabel(&quot;r (m)&quot;)
title(&quot;co-rotating field&quot;)
contourf(rgrid, zgrid, log.(norm_factor * Hco)&#39;, [-11,-6,-5.5,-5.0,-4.5,-4.0,-3.0,-2.0,-0.0], cmap=&quot;jet&quot;)
gca().invert_yaxis()
sca(ax[2])
title(&quot;counter-rotating field&quot;)
xlabel(&quot;r (m)&quot;)
cs = contourf(rgrid, zgrid, log.(norm_factor * H_counter)&#39;, [-11,-6,-5.5,-5.0,-4.5,-4.0,-3.0,-2.0,-0.0], cmap=&quot;jet&quot;)
gca().invert_yaxis()

colorbar(cs,location=&quot;bottom&quot;, ax=ax, label = &quot;log B&quot;)
gcf()</code></pre><p><img src="../1520085158.png" alt/></p><h2 id="Modelling-kernel"><a class="docs-heading-anchor" href="#Modelling-kernel">Modelling kernel</a><a id="Modelling-kernel-1"></a><a class="docs-heading-anchor-permalink" href="#Modelling-kernel" title="Permalink"></a></h2><p>We can also compute the sensitivity of the MRS experiment to water in different locations relative to the loop (the kernel), which is done for a number of pulse moments to produce the forward model.</p><pre><code class="language-julia hljs">#
μ = SNMRForward.μ0
kernel = SNMRForward.point_kernel.(10, μ * Hco, μ * H_counter, ζ, ωl)

kernel *= SNMRForward.mag_factor(300.0) * ωl/SNMRForward.γh

#
figure()
cs = contourf(rgrid, zgrid, real.(kernel)&#39;/3.89619e-10, levels = [-0.1,-0.05,-0.02,-0.01,0.01,0.02,0.05,0.1],cmap = &quot;gist_stern&quot;)
gca().invert_yaxis()
colorbar(cs)
gcf()</code></pre><p><img src="../2547873243.png" alt/></p><p>Integrating the kernel horizontally produces a 1D kernel, showing sensitivity to laterally contiguous water layers at each depth in the modelling grid.</p><pre><code class="language-julia hljs">#
n_theta_points = 100
thetagrid = range(0, 2*pi, length=n_theta_points)

#radial integral scale
dr = (rgrid[2] - rgrid[1]) * rgrid
#azimuthal integral scale
dtheta = thetagrid[2] - thetagrid[1]

k1d = zeros(ComplexF64, size(zgrid)...)

q = 10
for (i_th, θ) = enumerate(thetagrid)
    Hparams = SNMRForward.co_counter_field.(Hz, Hr, ϕ, θ)

    Hco = first.(Hparams)
    ζ = last.(Hparams)
    Hctr = reshape([a[2] for a in Hparams[:]], size(Hco)...)

    kernel = SNMRForward.point_kernel.(q, μ * Hco, μ * Hctr, ζ, ωl)
    global k1d += dtheta*transpose(kernel)*dr
end

#

Be = ωl/SNMRForward.γh
m0 = SNMRForward.mag_factor(300) * Be


#
full_kernel = k1d * m0 # in V/m
figure()
plot(real.(full_kernel * 10^9), zgrid)
gca().set_yscale(&quot;log&quot;)
gca().invert_yaxis()
gcf()</code></pre><p><img src="../1973060515.png" alt/></p><h2 id="Tipping-angle"><a class="docs-heading-anchor" href="#Tipping-angle">Tipping angle</a><a id="Tipping-angle-1"></a><a class="docs-heading-anchor-permalink" href="#Tipping-angle" title="Permalink"></a></h2><p>The &quot;tipping angle&quot; is the amount by which the exciting field rotates the magnetisation of subsurface water away from the geomagnetic field. At shallow depths where the excitation field is strong, the magnetisation may be rotated through one or more full revolutions, although this will not increase the signal from the free induction decay because the maximum signal is produced at a tipping angle of π/2 (perpendicular to the geomagnetic field).</p><pre><code class="language-julia hljs">#
θ = -π/2
Hp1 = SNMRForward.co_counter_field.(Hz, Hr, ϕ, θ)
Hp2 = SNMRForward.co_counter_field.(Hz, Hr, ϕ, θ + π)

Hparams = vcat(Hp1[end:-1:1, :], Hp2)

Hco = first.(Hparams)
ζ = last.(Hparams)
Hctr = reshape([a[2] for a in Hparams[:]], size(Hco)...)

q = 10
αt = ((SNMRForward.γh * q * μ * Hco) .% (2*π))/π * 180

xs = vcat(-reverse(rgrid), rgrid)

figure(figsize=(10,5))
cs = contourf(xs, zgrid, αt&#39;, levels=[0,45,90,135,210,225,270,315,360])
gca().invert_yaxis()
xlabel(&quot;distance from loop centre (m)&quot;)
ylabel(&quot;depth (m)&quot;)
colorbar(cs, label = &quot;excitation angle (degrees)&quot;)
gcf()</code></pre><p><img src="../3399265358.png" alt/></p><h2 id="D-kernel-for-different-pulse-moments"><a class="docs-heading-anchor" href="#D-kernel-for-different-pulse-moments">1D kernel for different pulse moments</a><a id="D-kernel-for-different-pulse-moments-1"></a><a class="docs-heading-anchor-permalink" href="#D-kernel-for-different-pulse-moments" title="Permalink"></a></h2><p>We can write a function to compute the 1D kernel for a given pulse moment, and explore how pulse moments change the depth sensitivity of the MRS experiment.</p><pre><code class="language-julia hljs">#
function kernel_1d(q, ϕ, ωl, Hz, Hr)
    n_theta_points = 100
    thetagrid = range(0, 2*pi, length=n_theta_points)

    #radial integral scale
    dr = (rgrid[2] - rgrid[1]) * rgrid
    #azimuthal integral scale
    dtheta = thetagrid[2] - thetagrid[1]

    k1d = zeros(ComplexF64, size(Hz,2))

    for (i_th, θ) = enumerate(thetagrid)
        Hparams = SNMRForward.co_counter_field.(Hz, Hr, ϕ, θ)

        Hco = first.(Hparams)
        ζ = last.(Hparams)
        Hctr = reshape([a[2] for a in Hparams[:]], size(Hco)...)

        kernel = SNMRForward.point_kernel.(q, μ * Hco, μ * Hctr, ζ, ωl)
        k1d += dtheta*transpose(kernel)*dr
    end
    k1d
end

# contour plot of 1D kernel (cf. fig. 5.6, Hertrich)
qgrid = [0.1,0.25,0.5,0.75,1,2,3,4,5,6,7,8,9,10,11] .* 2
ϕ = 12*π/36

kq = reduce(hcat, kernel_1d(q, ϕ, ωl, Hz, Hr) for q in qgrid)

#
fig, ax = subplots(1,1,figsize=(5,10))
contourf(qgrid, zgrid, 10^9 * real.(kq*m0), cmap=&quot;RdBu_r&quot;, levels=[-150,-100,-50,-25,0,25,50,100,150])
gca().invert_yaxis()
xlabel(&quot;q (A s)&quot;)
ylabel(&quot;Depth (m)&quot;)
colorbar(label = &quot;Real part of 1D kernel (nV/m)&quot;)
gcf()

# &quot;log sensitivity&quot; (Fig. 5.5, Hertrich)
fig, ax = subplots(1,1,figsize=(7,10))
contourf(qgrid, zgrid, log10.(10^9 * abs.(kq*m0)), levels=[-1,0.1,0.6,1.15,1.7,2.5], cmap=&quot;jet&quot;)
gca().invert_yaxis()
xlabel(&quot;Pulse moment (A s)&quot;)
ylabel(&quot;Depth (m)&quot;)
colorbar(label = &quot;log(1D sensitivity (nV/m))&quot;)
gcf()</code></pre><p><img src="../1872006475.png" alt/></p><h2 id="Forward-modelling-of-the-sounding-curve"><a class="docs-heading-anchor" href="#Forward-modelling-of-the-sounding-curve">Forward modelling of the sounding curve</a><a id="Forward-modelling-of-the-sounding-curve-1"></a><a class="docs-heading-anchor-permalink" href="#Forward-modelling-of-the-sounding-curve" title="Permalink"></a></h2><p>The result of the forward modelling is a &quot;sounding curve&quot; - this corresponds to the initial amplitude of the free induction decay signal recorded by the receiver, for each pulse moment. We can examine the sounding curves for fully saturated water layers at different thicknesses and depths.</p><pre><code class="language-julia hljs"># do an actual forward model
dz = zgrid[2] - zgrid[1]
fwd_kernel = kq * m0
# 10 - 20 m
w = zeros(length(zgrid))
w[(zgrid .&gt;= 10) .&amp; (zgrid .&lt;= 20)] .= 1

response = transpose(fwd_kernel) * w * dz

fig, ax = subplots(1,3, figsize=(15,5))
sca(ax[1])
plot(qgrid, real.(response))
title(&quot;Saturated layer 10 - 20 m&quot;)
ylabel(&quot;Response voltage (V)&quot;)
xlabel(&quot;Pulse moment (A s)&quot;)
# 30 - 45 m
w = zeros(length(zgrid))
w[(zgrid .&gt;= 30) .&amp; (zgrid .&lt;= 45)] .= 1

response = transpose(fwd_kernel) * w * dz

sca(ax[2])
plot(qgrid, real.(response))
title(&quot;Saturated layer 30 - 45 m&quot;)
xlabel(&quot;Pulse moment (A s)&quot;)
# 60 - 80 m
w = zeros(length(zgrid))
w[(zgrid .&gt;= 60) .&amp; (zgrid .&lt;= 80)] .= 1

response = transpose(fwd_kernel) * w * dz

sca(ax[3])
plot(qgrid, real.(response))
title(&quot;Saturated layer 60 - 80 m&quot;)
xlabel(&quot;Pulse moment (A s)&quot;)
gcf()
#</code></pre><p><img src="../1054674113.png" alt/></p><h2 id="Depth-slices-of-sensitivity"><a class="docs-heading-anchor" href="#Depth-slices-of-sensitivity">Depth slices of sensitivity</a><a id="Depth-slices-of-sensitivity-1"></a><a class="docs-heading-anchor-permalink" href="#Depth-slices-of-sensitivity" title="Permalink"></a></h2><p>We can explore the kernel a bit more by looking at depth slices, showing how sensitivity even at a constant depth can change with lateral position</p><pre><code class="language-julia hljs"># horizontal cross section of the kernel
q = 10
Hz_cross = Hz[:,6]
Hr_cross = Hr[:,6]
thetagrid = (0:1:360)./360 * 2 * π

Hfield_params = reduce(hcat, SNMRForward.co_counter_field.(Hz_cross, Hr_cross, 13*π/36, θ) for θ in thetagrid)
Hco = first.(Hfield_params)
ζ = last.(Hfield_params)
H_counter = reshape([a[2] for a in Hfield_params[:]], size(Hco)...)
kernel_cross = m0 * SNMRForward.point_kernel.(q, μ*Hco, μ*H_counter, ζ, ωl) * 10^9

fig = figure()
ax = fig.add_subplot(projection=&quot;polar&quot;)
ax.set_theta_zero_location(&quot;N&quot;)
ax.set_rticks([25,50,75,100])
ax.set_yticklabels([&quot;25&quot;,&quot;50&quot;,&quot;75&quot;,&quot;r = 100 m&quot;])
pcolormesh(thetagrid, rgrid, real.(kernel_cross)/0.059512, cmap=&quot;RdBu&quot;, vmin=-1.0, vmax = 1.0)
colorbar(label=&quot;Normalised real kernel&quot;)
gcf()</code></pre><p><img src="../1369976658.png" alt/></p><h2 id="The-forward-modelling-API"><a class="docs-heading-anchor" href="#The-forward-modelling-API">The forward modelling API</a><a id="The-forward-modelling-API-1"></a><a class="docs-heading-anchor-permalink" href="#The-forward-modelling-API" title="Permalink"></a></h2><p>Now let&#39;s actually use the defined forward modelling API, having shown what we&#39;re doing &quot;under the hood&quot;.</p><pre><code class="language-julia hljs"># Actually use the defined structs in the package to do forward modelling
condLEM = SNMRForward.ConductivityModel(σ, d)
qgrid = [0.1,0.25,0.5,0.75,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]
ϕ = 13*π/36
F = SNMRForward.MRSForward(R, zgrid, qgrid, ϕ, Be, condLEM)
#
w = zeros(length(zgrid))
w[(zgrid .&gt;= 30) .&amp; (zgrid .&lt;= 45)] .= 1
data = SNMRForward.forward(F,w)

figure()
plot(qgrid,real.(data))
gcf()
#


w = zeros(length(zgrid))
w[(zgrid .&gt;= 10) .&amp; (zgrid .&lt;= 20)] .= 1
response = SNMRForward.forward(F,w)

fig, ax = subplots(1,3, figsize=(15,5))
sca(ax[1])
plot(qgrid, real.(response))
title(&quot;Saturated layer 10 - 20 m&quot;)
ylabel(&quot;Response voltage (V)&quot;)
xlabel(&quot;Pulse moment (A s)&quot;)
gca().ticklabel_format(axis=&quot;y&quot;, style=&quot;sci&quot;, scilimits=(0,0))
# 30 - 45 m
w = zeros(length(zgrid))
w[(zgrid .&gt;= 30) .&amp; (zgrid .&lt;= 45)] .= 1

response = SNMRForward.forward(F,w)

sca(ax[2])
plot(qgrid, real.(response))
title(&quot;Saturated layer 30 - 45 m&quot;)
xlabel(&quot;Pulse moment (A s)&quot;)
gca().ticklabel_format(axis=&quot;y&quot;, style=&quot;sci&quot;, scilimits=(0,0))
# 60 - 80 m
w = zeros(length(zgrid))
w[(zgrid .&gt;= 60) .&amp; (zgrid .&lt;= 80)] .= 1

response = SNMRForward.forward(F,w)

sca(ax[3])
plot(qgrid, real.(response))
title(&quot;Saturated layer 60 - 80 m&quot;)
xlabel(&quot;Pulse moment (A s)&quot;)
gca().ticklabel_format(axis=&quot;y&quot;, style=&quot;sci&quot;, scilimits=(0,0))
gcf()
#</code></pre><p><img src="../1261121431.png" alt/></p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« SNMRForward.jl Documentation</a><a class="docs-footer-nextpage" href="../../forward_modelling/">Forward Modelling »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Wednesday 29 June 2022 01:16">Wednesday 29 June 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
